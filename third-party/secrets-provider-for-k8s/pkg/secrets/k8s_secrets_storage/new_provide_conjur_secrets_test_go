package k8ssecretsstorage

import (
	"fmt"
	"reflect"
	"testing"

	//. "github.com/smartystreets/goconvey/convey"
	"github.com/stretchr/testify/assert"
	v1 "k8s.io/api/core/v1"

	"github.com/cyberark/secrets-provider-for-k8s/pkg/log/messages"
	secretsStorageMocks "github.com/cyberark/secrets-provider-for-k8s/pkg/secrets/k8s_secrets_storage/mocks"
)

func TestRetrieveRequiredK8sSecrets(t *testing.T) {

	type assertFunc func(*k8sSecretsState, error, string)

	assertErrorContains := func(expErrStr string) assertFunc {
		return func(
			secretsState *k8sSecretsState,
			err error,
			desc string) {
			assert.Error(t, err, desc)
			assert.Contains(t, err.Error(), expErrStr, desc)
		}
	}

	assertExpK8sSecretsState := func(expK8sSecretsState *k8sSecretsState) assertFunc {
		return func(secretsState *k8sSecretsState, err error, desc string) {
			assert.NoError(t, err, desc)
			assert.True(t, reflect.DeepEqual(
				secretsState.k8sSecretsMap,
				expK8sSecretsState.k8sSecretsMap),
				desc+", Error: unexpected K8sSecrets")
			assert.True(t, reflect.DeepEqual(
				secretsState.originalK8sSecrets,
				expK8sSecretsState.originalK8sSecrets),
				desc+", Error: unexpected originalK8sSecrets")
			assert.True(t, reflect.DeepEqual(
				secretsState.updateDestinations,
				expK8sSecretsState.updateDestinations),
				desc+", Error: unexpected updateDestinations")
		}
	}

	testCases := []struct {
		desc                string
		k8sSecrets          secretsStorageMocks.K8sSecrets
		requiredSecrets     []string
		secretsAccessDenied bool
		assert              assertFunc
	}{
		{
			desc: "Happy path, existing k8s Secret with existing Conjur secret",
			k8sSecrets: secretsStorageMocks.K8sSecrets{
				"k8s-secret1": {
					"conjur-map": {
						"conjur-secret1": "conjur/var/path1",
					},
				},
			},
			requiredSecrets: []string{"k8s-secret1"},
			assert: assertExpK8sSecretsState(
				&k8sSecretsState{
					k8sSecretsMap: map[string]conjurSecretsPaths{
						"k8s-secret1": conjurSecretsPaths{
							"conjur-secret1": "conjur/var/path1",
						},
					},
					originalK8sSecrets: map[string]*v1.Secret{
						"k8s-secret1": &v1.Secret{
							Data: map[string][]byte{
								"conjur-map": []byte("conjur-secret1: conjur/var/path1\n"),
							},
						},
					},
					updateDestinations: map[string][]updateDestination{
						"conjur/var/path1": {
							{
								k8sSecretName: "k8s-secret1",
								secretName:    "conjur-secret1",
							},
						},
					},
				},
			),
		},
		{
			desc: "Happy path, 2 existing k8s Secrets with 2 existing Conjur secrets",
			k8sSecrets: secretsStorageMocks.K8sSecrets{
				"k8s-secret1": {
					"conjur-map": {
						"conjur-secret1": "conjur/var/path1",
						"conjur-secret2": "conjur/var/path2",
					},
				},
				"k8s-secret2": {
					"conjur-map": {
						"conjur-secret3": "conjur/var/path3",
						"conjur-secret4": "conjur/var/path4",
					},
				},
			},
			requiredSecrets: []string{"k8s-secret1", "k8s-secret2"},
			assert: assertExpK8sSecretsState(
				&k8sSecretsState{
					k8sSecretsMap: map[string]conjurSecretsPaths{
						"k8s-secret1": conjurSecretsPaths{
							"conjur-secret1": "conjur/var/path1",
							"conjur-secret2": "conjur/var/path2",
						},
						"k8s-secret2": conjurSecretsPaths{
							"conjur-secret3": "conjur/var/path3",
							"conjur-secret4": "conjur/var/path4",
						},
					},
					originalK8sSecrets: map[string]*v1.Secret{
						"k8s-secret1": &v1.Secret{
							Data: map[string][]byte{
								"conjur-map": []byte(
									"conjur-secret1: conjur/var/path1\n" +
										"conjur-secret2: conjur/var/path2\n"),
							},
						},
						"k8s-secret2": &v1.Secret{
							Data: map[string][]byte{
								"conjur-map": []byte(
									"conjur-secret3: conjur/var/path3\n" +
										"conjur-secret4: conjur/var/path4\n"),
							},
						},
					},
					updateDestinations: map[string][]updateDestination{
						"conjur/var/path1": {
							{
								k8sSecretName: "k8s-secret1",
								secretName:    "conjur-secret1",
							},
						},
						"conjur/var/path2": {
							{
								k8sSecretName: "k8s-secret1",
								secretName:    "conjur-secret2",
							},
						},
						"conjur/var/path3": {
							{
								k8sSecretName: "k8s-secret2",
								secretName:    "conjur-secret3",
							},
						},
						"conjur/var/path4": {
							{
								k8sSecretName: "k8s-secret2",
								secretName:    "conjur-secret4",
							},
						},
					},
				},
			),
		},
		{
			desc: "Access to K8s 'Secrets' is not allowed",
			k8sSecrets: secretsStorageMocks.K8sSecrets{
				"k8s-secret1": {
					"conjur-map": {
						"conjur-secret1": "conjur/var/path1",
					},
				},
			},
			requiredSecrets:     []string{"k8s-secret1"},
			secretsAccessDenied: true,
			assert:              assertErrorContains(messages.CSPFK020E),
		},
		{
			desc: "K8s secret is required but does not exist",
			k8sSecrets: secretsStorageMocks.K8sSecrets{
				"k8s-secret1": {
					"conjur-map": {
						"conjur-secret1": "conjur/var/path1",
					},
				},
			},
			requiredSecrets: []string{"non-existent-k8s-secret"},
			assert:          assertErrorContains(messages.CSPFK020E),
		},
		{
			desc: "K8s secret has an empty 'conjur-map' entry",
			k8sSecrets: secretsStorageMocks.K8sSecrets{
				"k8s-secret1": {
					"conjur-map": {},
				},
			},
			requiredSecrets: []string{"k8s-secret1"},
			assert: assertErrorContains(
				fmt.Sprintf(messages.CSPFK028E, "k8s-secret1")),
		},
	}

	for _, tc := range testCases {
		// Set up test case
		kubeMockClient := secretsStorageMocks.NewKubeSecretsMockClient()
		if tc.secretsAccessDenied {
			kubeMockClient.CanRetrieve = false
		}
		for k8sSecretName, secretData := range tc.k8sSecrets {
			kubeMockClient.AddSecret(k8sSecretName, secretData)
		}
		mockK8sProvider := newProvider(
			kubeMockClient.RetrieveSecret,
			kubeMockClient.UpdateSecret,
			func([]string) (map[string][]byte, error) { return nil, nil },
			tc.requiredSecrets,
			"someNamespace")

		// Run test case
		secretsState, err := mockK8sProvider.retrieveRequiredK8sSecrets()

		// Confirm results
		tc.assert(secretsState, err, tc.desc)
	}
}

func TestRetrieveConjurSecrets(t *testing.T) {

	type assertFunc func(*map[string][]byte, error, string)

	assertErrorContains := func(expErrStr string) assertFunc {
		return func(retrievedSecrets map[string][]byte, err error, desc string) {
			assert.Error(t, err, desc)
			assert.Contains(t, err.Error(), expErrStr, desc)
		}
	}

	assertExpectedSecrets := func(expectedSecrets map[string][]byte) assertFunc {
		return func(retrievedSecrets map[string][]byte, err error, desc string) {
			assert.NoError(t, err, desc)
			assert.Equal(t, len(retrievedSecrets), len(expectedSecrets),
				desc+", Error: unexpected number of retrieved secrets")
			for name, value := range retrievedSecrets {
				assert.Equalf(t, value, expectedSecrets[name],
					desc+", Error: unexpected value for secret '%s'", name)
			}
		}
	}

	testCases := []struct {
		desc                string
		k8sSecrets          secretsStorageMocks.K8sSecrets
		requiredSecrets     []string
		secretsAccessDenied bool
		assert              assertFunc
	}{
		{
			desc: "Happy path, existing k8s Secret with existing Conjur secret",
			k8sSecrets: secretsStorageMocks.K8sSecrets{
				"k8s-secret1": {
					"conjur-map": {
						"conjur-secret1": "conjur/var/path1",
					},
				},
			},
			requiredSecrets: []string{"k8s-secret1"},
			assert: assertExpK8sSecretsState(
				&k8sSecretsState{
					k8sSecretsMap: map[string]conjurSecretsPaths{
						"k8s-secret1": conjurSecretsPaths{
							"conjur-secret1": "conjur/var/path1",
						},
					},
					originalK8sSecrets: map[string]*v1.Secret{
						"k8s-secret1": &v1.Secret{
							Data: map[string][]byte{
								"conjur-map": []byte("conjur-secret1: conjur/var/path1\n"),
							},
						},
					},
					updateDestinations: map[string][]updateDestination{
						"conjur/var/path1": {
							{
								k8sSecretName: "k8s-secret1",
								secretName:    "conjur-secret1",
							},
						},
					},
				},
			),
		},
		{
			desc: "Happy path, 2 existing k8s Secrets with 2 existing Conjur secrets",
			k8sSecrets: secretsStorageMocks.K8sSecrets{
				"k8s-secret1": {
					"conjur-map": {
						"conjur-secret1": "conjur/var/path1",
						"conjur-secret2": "conjur/var/path2",
					},
				},
				"k8s-secret2": {
					"conjur-map": {
						"conjur-secret3": "conjur/var/path3",
						"conjur-secret4": "conjur/var/path4",
					},
				},
			},
			requiredSecrets: []string{"k8s-secret1", "k8s-secret2"},
			assert: assertExpK8sSecretsState(
				&k8sSecretsState{
					k8sSecretsMap: map[string]conjurSecretsPaths{
						"k8s-secret1": conjurSecretsPaths{
							"conjur-secret1": "conjur/var/path1",
							"conjur-secret2": "conjur/var/path2",
						},
						"k8s-secret2": conjurSecretsPaths{
							"conjur-secret3": "conjur/var/path3",
							"conjur-secret4": "conjur/var/path4",
						},
					},
					originalK8sSecrets: map[string]*v1.Secret{
						"k8s-secret1": &v1.Secret{
							Data: map[string][]byte{
								"conjur-map": []byte(
									"conjur-secret1: conjur/var/path1\n" +
										"conjur-secret2: conjur/var/path2\n"),
							},
						},
						"k8s-secret2": &v1.Secret{
							Data: map[string][]byte{
								"conjur-map": []byte(
									"conjur-secret3: conjur/var/path3\n" +
										"conjur-secret4: conjur/var/path4\n"),
							},
						},
					},
					updateDestinations: map[string][]updateDestination{
						"conjur/var/path1": {
							{
								k8sSecretName: "k8s-secret1",
								secretName:    "conjur-secret1",
							},
						},
						"conjur/var/path2": {
							{
								k8sSecretName: "k8s-secret1",
								secretName:    "conjur-secret2",
							},
						},
						"conjur/var/path3": {
							{
								k8sSecretName: "k8s-secret2",
								secretName:    "conjur-secret3",
							},
						},
						"conjur/var/path4": {
							{
								k8sSecretName: "k8s-secret2",
								secretName:    "conjur-secret4",
							},
						},
					},
				},
			),
		},
		{
			desc: "Access to K8s 'Secrets' is not allowed",
			k8sSecrets: secretsStorageMocks.K8sSecrets{
				"k8s-secret1": {
					"conjur-map": {
						"conjur-secret1": "conjur/var/path1",
					},
				},
			},
			requiredSecrets:     []string{"k8s-secret1"},
			secretsAccessDenied: true,
			assert:              assertErrorContains(messages.CSPFK020E),
		},
		{
			desc: "K8s secret is required but does not exist",
			k8sSecrets: secretsStorageMocks.K8sSecrets{
				"k8s-secret1": {
					"conjur-map": {
						"conjur-secret1": "conjur/var/path1",
					},
				},
			},
			requiredSecrets: []string{"non-existent-k8s-secret"},
			assert:          assertErrorContains(messages.CSPFK020E),
		},
		{
			desc: "K8s secret has an empty 'conjur-map' entry",
			k8sSecrets: secretsStorageMocks.K8sSecrets{
				"k8s-secret1": {
					"conjur-map": {},
				},
			},
			requiredSecrets: []string{"k8s-secret1"},
			assert: assertErrorContains(
				fmt.Sprintf(messages.CSPFK028E, "k8s-secret1")),
		},
	}

	for _, tc := range testCases {
		// Set up test case
		kubeMockClient := secretsStorageMocks.NewKubeSecretsMockClient()
		if tc.secretsAccessDenied {
			kubeMockClient.CanRetrieve = false
		}
		for k8sSecretName, secretData := range tc.k8sSecrets {
			kubeMockClient.AddSecret(k8sSecretName, secretData)
		}
		mockK8sProvider := newProvider(
			kubeMockClient.RetrieveSecret,
			kubeMockClient.UpdateSecret,
			func([]string) (map[string][]byte, error) { return nil, nil },
			tc.requiredSecrets,
			"someNamespace")

		// Run test case
		secretsState, err := mockK8sProvider.retrieveRequiredK8sSecrets()

		// Confirm results
		tc.assert(secretsState, err, tc.desc)
	}
}
